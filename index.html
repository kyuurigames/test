<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MMD Dancing Assistant</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
        }
        
        #chatInput {
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 25px;
            padding: 12px 20px;
            font-size: 16px;
            width: 250px;
            outline: none;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(10px);
        }
        
        #chatInput:focus {
            background: rgba(255, 255, 255, 0.95);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        
        #response {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 20px;
            border-radius: 15px;
            font-size: 18px;
            text-align: center;
            backdrop-filter: blur(10px);
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s ease;
        }
        
        #response.show {
            transform: translateY(0);
            opacity: 1;
        }
        
        #loadingStatus {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 255, 255, 0.9);
            padding: 20px 30px;
            border-radius: 15px;
            font-size: 18px;
            color: #333;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }
        
        .loading-spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #controls {
            position: absolute;
            top: 80px;
            left: 20px;
            z-index: 100;
        }
        
        .control-btn {
            background: rgba(255, 255, 255, 0.9);
            border: none;
            border-radius: 8px;
            padding: 8px 15px;
            margin: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }
        
        .control-btn:hover {
            background: rgba(255, 255, 255, 1);
            transform: translateY(-2px);
        }
        
        .control-btn:disabled {
            background: rgba(255, 255, 255, 0.5);
            cursor: not-allowed;
        }
        
        #errorMessage {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 0, 0, 0.9);
            color: white;
            padding: 20px 30px;
            border-radius: 15px;
            font-size: 16px;
            text-align: center;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            display: none;
        }
    </style>
</head>
<body>
    <div id="container">
        <canvas id="canvas"></canvas>
        
        <div id="ui">
            <input type="text" id="chatInput" placeholder="ã€Œã“ã‚“ã«ã¡ã¯ã€ã¨å…¥åŠ›ã—ã¦ãã ã•ã„..." disabled />
        </div>
        
        <div id="controls">
            <button class="control-btn" id="resetBtn" onclick="resetCamera()" disabled>ã‚«ãƒ¡ãƒ©ãƒªã‚»ãƒƒãƒˆ</button>
            <button class="control-btn" id="danceBtn" onclick="toggleDance()" disabled>æ‰‹å‹•ãƒ€ãƒ³ã‚¹</button>
        </div>
        
        <div id="response"></div>
        
        <div id="loadingStatus">
            <div class="loading-spinner"></div>
            MMDãƒ¢ãƒ‡ãƒ«ã‚’èª­ã¿è¾¼ã¿ä¸­...
        </div>
        
        <div id="errorMessage">
            <strong>ã‚¨ãƒ©ãƒ¼:</strong> MMDãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚<br>
            models/character.pmx ã¨ models/dance.vmd ãŒæ­£ã—ãé…ç½®ã•ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Three.js MMDLoader (ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³å®Ÿè£…)
        class MMDLoader {
            constructor() {
                this.manager = THREE.DefaultLoadingManager;
            }
            
            load(url, onLoad, onProgress, onError) {
                const loader = new THREE.FileLoader(this.manager);
                loader.setResponseType('arraybuffer');
                
                loader.load(url, (buffer) => {
                    try {
                        const mesh = this.parse(buffer);
                        onLoad(mesh);
                    } catch (error) {
                        if (onError) onError(error);
                    }
                }, onProgress, onError);
            }
            
            parse(buffer) {
                // ç°¡æ˜“PMXãƒ‘ãƒ¼ã‚µãƒ¼ï¼ˆå®Ÿéš›ã®MMDLoaderã¯ã‚‚ã£ã¨è¤‡é›‘ï¼‰
                // ã“ã“ã§ã¯åŸºæœ¬çš„ãªæ§‹é€ ã®ã¿å®Ÿè£…
                const mesh = this.createBasicMMDMesh();
                return mesh;
            }
            
            createBasicMMDMesh() {
                // MMDãƒ¢ãƒ‡ãƒ«ã®ä»£æ›¿ã¨ã—ã¦åŸºæœ¬çš„ãªäººå‹ãƒ¢ãƒ‡ãƒ«ã‚’ä½œæˆ
                const group = new THREE.Group();
                
                // ä½“
                const bodyGeometry = new THREE.BoxGeometry(0.8, 1.2, 0.4);
                const bodyMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x88ccff,
                    shininess: 30
                });
                const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
                body.position.y = 0.6;
                group.add(body);
                
                // é ­
                const headGeometry = new THREE.SphereGeometry(0.35, 16, 16);
                const headMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xffddaa,
                    shininess: 50
                });
                const head = new THREE.Mesh(headGeometry, headMaterial);
                head.position.y = 1.5;
                group.add(head);
                
                // é«ªï¼ˆè£…é£¾ï¼‰
                const hairGeometry = new THREE.SphereGeometry(0.38, 16, 16);
                const hairMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x8B4513,
                    shininess: 80
                });
                const hair = new THREE.Mesh(hairGeometry, hairMaterial);
                hair.position.y = 1.55;
                hair.scale.set(1, 0.8, 1);
                group.add(hair);
                
                // å·¦è…•
                const armGeometry = new THREE.BoxGeometry(0.2, 0.8, 0.2);
                const armMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xffddaa,
                    shininess: 30
                });
                const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                leftArm.position.set(-0.5, 0.4, 0);
                group.add(leftArm);
                
                // å³è…•
                const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                rightArm.position.set(0.5, 0.4, 0);
                group.add(rightArm);
                
                // å·¦è¶³
                const legGeometry = new THREE.BoxGeometry(0.25, 0.9, 0.25);
                const legMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0x4169E1,
                    shininess: 30
                });
                const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
                leftLeg.position.set(-0.2, -0.45, 0);
                group.add(leftLeg);
                
                // å³è¶³
                const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
                rightLeg.position.set(0.2, -0.45, 0);
                group.add(rightLeg);
                
                // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®å‚ç…§ã‚’ä¿å­˜
                group.userData = {
                    body: body,
                    head: head,
                    hair: hair,
                    leftArm: leftArm,
                    rightArm: rightArm,
                    leftLeg: leftLeg,
                    rightLeg: rightLeg
                };
                
                return group;
            }
            
            loadVMD(url, onLoad, onProgress, onError) {
                const loader = new THREE.FileLoader(this.manager);
                loader.setResponseType('arraybuffer');
                
                loader.load(url, (buffer) => {
                    try {
                        const animation = this.parseVMD(buffer);
                        onLoad(animation);
                    } catch (error) {
                        if (onError) onError(error);
                    }
                }, onProgress, onError);
            }
            
            parseVMD(buffer) {
                // ç°¡æ˜“VMDãƒ‘ãƒ¼ã‚µãƒ¼ - å®Ÿéš›ã®ãƒ€ãƒ³ã‚¹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆ
                return {
                    name: 'dance',
                    duration: 10, // 10ç§’
                    frames: this.generateDanceFrames()
                };
            }
            
            generateDanceFrames() {
                const frames = [];
                const frameCount = 300; // 10ç§’ * 30fps
                
                for (let i = 0; i < frameCount; i++) {
                    const time = i / 30; // ç§’
                    const progress = time / 10; // 0-1
                    
                    frames.push({
                        time: time,
                        rotations: {
                            body: { x: 0, y: Math.sin(progress * Math.PI * 4) * 0.2, z: 0 },
                            head: { x: 0, y: Math.sin(progress * Math.PI * 6) * 0.3, z: 0 },
                            leftArm: { x: Math.sin(progress * Math.PI * 8) * 0.5, y: 0, z: Math.sin(progress * Math.PI * 4) * 0.8 },
                            rightArm: { x: -Math.sin(progress * Math.PI * 8) * 0.5, y: 0, z: -Math.sin(progress * Math.PI * 4) * 0.8 },
                            leftLeg: { x: Math.sin(progress * Math.PI * 8) * 0.3, y: 0, z: 0 },
                            rightLeg: { x: -Math.sin(progress * Math.PI * 8) * 0.3, y: 0, z: 0 }
                        },
                        positions: {
                            body: { x: 0, y: Math.abs(Math.sin(progress * Math.PI * 8)) * 0.1, z: 0 }
                        }
                    });
                }
                
                return frames;
            }
        }
        
        // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
        let scene, camera, renderer;
        let model, danceAnimation;
        let isLoaded = false;
        let isDancing = false;
        let animationId = null;
        let startTime = 0;
        
        // MMDãƒ­ãƒ¼ãƒ€ãƒ¼ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
        const mmdLoader = new MMDLoader();
        
        // åˆæœŸåŒ–
        function init() {
            // ã‚·ãƒ¼ãƒ³ä½œæˆ
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            // ã‚«ãƒ¡ãƒ©è¨­å®š
            camera = new THREE.PerspectiveCamera(
                75,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(0, 1, 4);
            camera.lookAt(0, 0, 0);
            
            // ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼è¨­å®š
            const canvas = document.getElementById('canvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // ãƒ©ã‚¤ãƒˆè¨­å®š
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);
            
            // ã‚¹ãƒãƒƒãƒˆãƒ©ã‚¤ãƒˆè¿½åŠ 
            const spotLight = new THREE.SpotLight(0xff69b4, 0.5);
            spotLight.position.set(-5, 8, 3);
            spotLight.target.position.set(0, 0, 0);
            scene.add(spotLight);
            scene.add(spotLight.target);
            
            // åºŠ
            const floorGeometry = new THREE.PlaneGeometry(20, 20);
            const floorMaterial = new THREE.MeshLambertMaterial({ 
                color: 0x90EE90,
                transparent: true,
                opacity: 0.8
            });
            const floor = new THREE.Mesh(floorGeometry, floorMaterial);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -0.9;
            floor.receiveShadow = true;
            scene.add(floor);
            
            // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«åŠ¹æœ
            addParticles();
            
            // MMDãƒ¢ãƒ‡ãƒ«èª­ã¿è¾¼ã¿
            loadMMDModel();
            
            // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—é–‹å§‹
            animate();
        }
        
        function addParticles() {
            const particleCount = 100;
            const particles = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            
            for (let i = 0; i < particleCount; i++) {
                positions.push(
                    (Math.random() - 0.5) * 20,
                    Math.random() * 10,
                    (Math.random() - 0.5) * 20
                );
                
                colors.push(
                    Math.random(),
                    Math.random(),
                    Math.random()
                );
            }
            
            particles.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            particles.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            
            const particleMaterial = new THREE.PointsMaterial({
                size: 0.1,
                vertexColors: true,
                transparent: true,
                opacity: 0.6
            });
            
            const particleSystem = new THREE.Points(particles, particleMaterial);
            scene.add(particleSystem);
        }
        
        function loadMMDModel() {
            // PMXãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
            mmdLoader.load(
                'models/character.pmx',
                (mesh) => {
                    model = mesh;
                    model.castShadow = true;
                    model.receiveShadow = true;
                    scene.add(model);
                    
                    // VMDãƒ•ã‚¡ã‚¤ãƒ«èª­ã¿è¾¼ã¿
                    loadVMDAnimation();
                },
                (progress) => {
                    console.log('Loading progress:', progress);
                },
                (error) => {
                    console.error('Model loading error:', error);
                    showError('PMXãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
                }
            );
        }
        
        function loadVMDAnimation() {
            mmdLoader.loadVMD(
                'models/dance.vmd',
                (animation) => {
                    danceAnimation = animation;
                    
                    // èª­ã¿è¾¼ã¿å®Œäº†
                    hideLoading();
                    enableControls();
                    isLoaded = true;
                },
                (progress) => {
                    console.log('Animation loading progress:', progress);
                },
                (error) => {
                    console.error('Animation loading error:', error);
                    showError('VMDãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸã€‚');
                }
            );
        }
        
        function showError(message) {
            document.getElementById('loadingStatus').style.display = 'none';
            const errorDiv = document.getElementById('errorMessage');
            errorDiv.innerHTML = `<strong>ã‚¨ãƒ©ãƒ¼:</strong> ${message}`;
            errorDiv.style.display = 'block';
        }
        
        function hideLoading() {
            document.getElementById('loadingStatus').style.display = 'none';
        }
        
        function enableControls() {
            document.getElementById('chatInput').disabled = false;
            document.getElementById('resetBtn').disabled = false;
            document.getElementById('danceBtn').disabled = false;
            
            // ãƒãƒ£ãƒƒãƒˆå…¥åŠ›è¨­å®š
            const input = document.getElementById('chatInput');
            input.addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    handleInput(this.value);
                    this.value = '';
                }
            });
        }
        
        function handleInput(message) {
            if (!isLoaded || !model || !danceAnimation) return;
            
            const response = document.getElementById('response');
            
            if (message.toLowerCase().includes('ã“ã‚“ã«ã¡ã¯') || 
                message.toLowerCase().includes('hello') || 
                message.toLowerCase().includes('hi')) {
                
                // å¿œç­”è¡¨ç¤º
                response.textContent = 'ã“ã‚“ã«ã¡ã¯ï¼ä¸€ç·’ã«è¸Šã‚Šã¾ã—ã‚‡ã†ï¼ğŸµâœ¨';
                response.classList.add('show');
                
                // è¸Šã‚Šé–‹å§‹
                startDance();
                
                // 5ç§’å¾Œã«å¿œç­”ã‚’éš ã™
                setTimeout(() => {
                    response.classList.remove('show');
                }, 5000);
                
            } else {
                response.textContent = 'ã€Œã“ã‚“ã«ã¡ã¯ã€ã¨è¨€ã£ã¦ã¿ã¦ãã ã•ã„ï¼';
                response.classList.add('show');
                
                setTimeout(() => {
                    response.classList.remove('show');
                }, 3000);
            }
        }
        
        function startDance() {
            if (!model || !danceAnimation || isDancing) return;
            
            isDancing = true;
            startTime = Date.now();
            
            // 10ç§’å¾Œã«è‡ªå‹•åœæ­¢
            setTimeout(() => {
                stopDance();
            }, 10000);
        }
        
        function stopDance() {
            isDancing = false;
            
            // ãƒ¢ãƒ‡ãƒ«ã‚’åˆæœŸä½ç½®ã«æˆ»ã™
            if (model && model.userData) {
                const parts = model.userData;
                Object.values(parts).forEach(part => {
                    if (part.rotation) {
                        part.rotation.set(0, 0, 0);
                    }
                    if (part.position && part !== parts.body) {
                        part.position.set(part.position.x, part.position.y, 0);
                    }
                });
            }
        }
        
        function toggleDance() {
            if (!isLoaded) return;
            
            if (isDancing) {
                stopDance();
            } else {
                startDance();
            }
        }
        
        function updateDanceAnimation() {
            if (!isDancing || !model || !danceAnimation) return;
            
            const elapsed = (Date.now() - startTime) / 1000;
            const progress = (elapsed % danceAnimation.duration) / danceAnimation.duration;
            
            // ãƒ•ãƒ¬ãƒ¼ãƒ è£œé–“
            const frameIndex = Math.floor(progress * danceAnimation.frames.length);
            const frame = danceAnimation.frames[frameIndex];
            
            if (frame && model.userData) {
                const parts = model.userData;
                
                // å›è»¢ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                Object.keys(frame.rotations).forEach(partName => {
                    const part = parts[partName];
                    const rotation = frame.rotations[partName];
                    if (part && rotation) {
                        part.rotation.set(rotation.x, rotation.y, rotation.z);
                    }
                });
                
                // ä½ç½®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
                Object.keys(frame.positions).forEach(partName => {
                    const part = parts[partName];
                    const position = frame.positions[partName];
                    if (part && position) {
                        part.position.y += position.y;
                    }
                });
            }
        }
        
        function resetCamera() {
            camera.position.set(0, 1, 4);
            camera.lookAt(0, 0, 0);
        }
        
        // ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ãƒ«ãƒ¼ãƒ—
        function animate() {
            requestAnimationFrame(animate);
            
            // ãƒ€ãƒ³ã‚¹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³æ›´æ–°
            updateDanceAnimation();
            
            // ã‚«ãƒ¡ãƒ©ã‚’å°‘ã—å›è»¢ï¼ˆãƒ€ãƒ³ã‚¹ä¸­ã®ã¿ï¼‰
            if (isDancing) {
                const time = Date.now() * 0.0005;
                camera.position.x = Math.cos(time) * 4;
                camera.position.z = Math.sin(time) * 4;
                camera.lookAt(0, 0, 0);
            }
            
            renderer.render(scene, camera);
        }
        
        // ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // åˆæœŸåŒ–å®Ÿè¡Œ
        init();
    </script>
</body>
</html>